(function(){"use strict";var e={7338:function(e,t,a){var n=a(9242),i=a(2013),l=a(3835),r=(a(4415),a(3396));function o(e,t,a,n,i,l){const o=(0,r.up)("ReportPage");return(0,r.wg)(),(0,r.j4)(o)}const s=e=>((0,r.dD)("data-v-3dbb9389"),e=e(),(0,r.Cn)(),e),c={class:"home"},f={class:"common-layout"},u=s((()=>(0,r._)("h1",{id:"MISCSIM23"},"Misc Physics Simulation Demoes",-1))),d=s((()=>(0,r._)("br",null,null,-1))),m={style:{"text-align":"left"}},h=s((()=>(0,r._)("h2",{id:"1. Introduction",style:{"text-align":"left"}},"1. PBD Rigid Body by Shape Matching",-1))),p=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," Implement PBD (Position Based Dynamics) rigid body collision. Every particle moves and collides individually, and then use shape matching to recover the shape of the rigid body. ",-1))),b=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," The implementation is writen in C++ (host) and visualized by OpenGL: ",-1))),g=s((()=>(0,r._)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/ehA1nLbxIGw",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:""},null,-1))),w=s((()=>(0,r._)("h2",{id:"2."},"2. Double Pendulum",-1))),y=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," Deriving double pendulum kinetic energy and potential energy. Using optimality for least action, we could write down the ODE of double pendulum. Then I use RK4 to solve the ODE and get the trajectory of the double pendulum. ",-1))),_=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," To keep the result simple let's just say: ",-1))),x=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," To further simplify, we observe that: ",-1))),W=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," And the final ODE is just: ",-1))),k=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," The implementation is based on Houdini: ",-1))),v=s((()=>(0,r._)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/R0VZUmkZooQ",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:""},null,-1))),$=s((()=>(0,r._)("h2",{id:"3."},"3. Softbody 3D Tetrahedral",-1))),U=s((()=>(0,r._)("h3",{id:"3.1.1",style:{"margin-top":"0in"}},"3.1 Per Cell Force computation",-1))),j={style:{"text-align":"left"}},T=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," In the first pass, we iterate throught all the tetrahedral, compute the force it distributes to each of its vertices. ",-1))),F=s((()=>(0,r._)("h3",{id:"3.1.2",style:{"margin-top":"0in"}},"3.1.1 Deformation Gradient",-1))),I=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," For simplicity, we should simply consider Lagragian coordinate M as reference space and Eulerian coordinate W as actual world space here. ",-1))),P=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," Then the state of a deformable body is a flow map $\\Phi: M\\rightarrow W$. We could expect that this flow map contains the information about how much deformation is happening. ",-1))),X={style:{"text-align":"left"}},E={style:{"text-align":"left"}},S={style:{"text-align":"left"}},C={style:{"text-align":"left"}},B={style:{"text-align":"left"}},O={style:{"text-align":"left"}},D={style:{"text-align":"left"}},A=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," But we should notice that the F also contains rotation, which is again not related to deformation, so we should further doing more things on F to eliminate rotation, extract the deformation representation. That is strain. ",-1))),M=s((()=>(0,r._)("h3",{id:"3.3",style:{"margin-top":"0in"}},"3.1.2 Strain",-1))),Y={style:{"text-align":"left"}},Z={style:{"text-align":"left"}},G={style:{"text-align":"left"}},V={style:{"text-align":"left"}},L={style:{"text-align":"left"}},R={style:{"text-align":"left"}},z={style:{"text-align":"left"}},K={style:{"text-align":"left"}},q=s((()=>(0,r._)("h3",{id:"3.4",style:{"margin-top":"0in"}},"3.1.3 Forcce",-1))),H={style:{"text-align":"left"}},N={style:{"text-align":"left"}},Q={style:{"text-align":"left"}},J={style:{"text-align":"left"}},ee=s((()=>(0,r._)("h3",{id:"3.4",style:{"margin-top":"0in"}},"3.2 Intermediate Connection",-1))),te={style:{"text-align":"left"}},ae={style:{"text-align":"left"}},ne=s((()=>(0,r._)("h3",{id:"3.4",style:{"margin-top":"0in"}},"3.3 Per Vertex Equation of Motion",-1))),ie=s((()=>(0,r._)("p",{style:{"text-align":"left"}}," Given the force, we could use the equation of motion to do time integration. ",-1))),le={style:{"text-align":"left"}},re=s((()=>(0,r._)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/N3MmjSIYpBI",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:""},null,-1))),oe=s((()=>(0,r._)("h2",{id:"2."},"4. FLIP 2D Fluid",-1))),se={style:{"text-align":"left"}},ce=s((()=>(0,r._)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/I1V52ImMg4E",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:""},null,-1)));function fe(e,t,a,n,i,l){const o=(0,r.up)("el-header"),s=(0,r.up)("el-row"),fe=(0,r.up)("el-link"),ue=(0,r.up)("el-col"),de=(0,r.up)("math-jax"),me=(0,r.up)("el-main"),he=(0,r.up)("el-divider"),pe=(0,r.up)("el-footer"),be=(0,r.up)("el-container");return(0,r.wg)(),(0,r.iD)("div",c,[(0,r._)("div",f,[(0,r.Wm)(be,null,{default:(0,r.w5)((()=>[(0,r.Wm)(be,null,{default:(0,r.w5)((()=>[(0,r.Wm)(o,null,{default:(0,r.w5)((()=>[u])),_:1}),(0,r.Wm)(be,null,{default:(0,r.w5)((()=>[(0,r.Wm)(be,null,{default:(0,r.w5)((()=>[(0,r.Wm)(me,null,{default:(0,r.w5)((()=>[(0,r.Wm)(s,{class:"row-bg"},{default:(0,r.w5)((()=>[d])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",m,[(0,r.Uk)(" This page includes some of miscellaneous physics simulation demoes written in 2022 ~ 2023. Some of them are personal projects, some of them are course projects of "),(0,r.Wm)(fe,{href:"https://cseweb.ucsd.edu/~alchern/teaching/cse291_sp23//",target:"_blank",type:"primary"},{default:(0,r.w5)((()=>[(0,r.Uk)("CSE 291")])),_:1}),(0,r.Uk)(" instructed by Professor "),(0,r.Wm)(fe,{href:"https://cseweb.ucsd.edu/~alchern/",target:"_blank",type:"primary"},{default:(0,r.w5)((()=>[(0,r.Uk)("Albert Chern")])),_:1}),(0,r.Uk)(". ")])])),_:1}),(0,r.Wm)(s,{class:"row-bg"},{default:(0,r.w5)((()=>[h,p])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[b])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(ue,{span:17},{default:(0,r.w5)((()=>[g])),_:1})])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[w])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[y])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[_])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(de,{latex:"\\begin{aligned}\n                  (\\frac{5}{3}+\\cos\\phi) \\ddot{\\theta} + (\\frac{1}{3}+\\frac{1}{2}\\cos\\phi)\\ddot{\\phi}=A\\\\\n                  (\\frac{1}{3}+\\frac{1}{2}\\cos\\phi)\\ddot{\\theta} + \\frac{1}{3}\\ddot{\\phi}= B\n                  \\end{aligned}\n                  "}),(0,r.Uk)(". ")])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[x])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(de,{latex:"\\begin{aligned}\n                  C = A-B = \\frac{1}{2}\\sin\\phi(\\dot{\\theta}+\\dot{\\phi})^2 -\\frac{3g}{2l}\\sin\\theta\\\\\n                  B = -\\frac{g}{2l}\\sin(\\theta+\\phi) - \\frac{1}{2}\\sin\\phi \\dot{\\theta}\\dot{\\theta}\\\\\n                  f = \\ddot{\\theta} = \\frac{18\\cos\\phi B -  12 C}{9\\cos\\phi^2 - 16}\\\\\n                  g = \\ddot{\\phi} = \\frac{(12+18\\cos\\phi)C - (48+18\\cos\\phi)B}{9(\\cos\\phi)^2 -16}\n                  \\end{aligned}\n                  "}),(0,r.Uk)(". ")])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[W])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(de,{latex:"\\frac{d}{dt}\\begin{bmatrix}\n                \\theta\\\\\n                \\phi\\\\\n                \\dot\\theta\\\\\n                \\dot \\phi\n                \\end{bmatrix}\n                = \\begin{bmatrix}\n                \\dot{\\theta}\\\\\n                \\dot{\\phi}\\\\\n                f(\\theta,\\phi,\\dot{\\theta},\\dot{\\phi})\\\\\n                g(\\theta,\\phi,\\dot{\\theta},\\dot{\\phi})\n                \\end{bmatrix}"}),(0,r.Uk)(". ")])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[k])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(ue,{span:17},{default:(0,r.w5)((()=>[v])),_:1})])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[$])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[U])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",j,[(0,r.Uk)(" As all the selected mesh used in the demo are composed by tetrahedral. Our basic discrete element is tetrahedral. Let's call the rest position "),(0,r.Wm)(de,{latex:"X_i"}),(0,r.Uk)(", which is given by the input file data, and the curretn world position "),(0,r.Wm)(de,{latex:"x_i"}),(0,r.Uk)(" is variable in the simulation. ")]),T])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[F])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[I,P,(0,r._)("p",X,[(0,r.Uk)(" If we consider coordinate. Then we could know: "),(0,r.Wm)(de,{latex:"$$\n                    \\begin{bmatrix}\n                        x\\\\y\\\\z\n                    \\end{bmatrix} = \\begin{bmatrix}\n                        \\phi^1(X,Y,Z)\\\\\n                        \\phi^2(X,Y,Z)\\\\\n                        \\phi^3(X,Y,Z)\n                    \\end{bmatrix}\n                    $$\n                    "})]),(0,r._)("p",E,[(0,r.Uk)(" Then we could get the deformation gradient "),(0,r.Wm)(de,{latex:"F=d\\phi"}),(0,r.Uk)(" as: "),(0,r.Wm)(de,{latex:"     \n                    $$\n                    F=\\begin{bmatrix}\n                        \\frac{\\partial \\phi^1}{\\partial X} & \n                        \\frac{\\partial \\phi^1}{\\partial Y} &\n                        \\frac{\\partial \\phi^1}{\\partial Z} \\\\\n                        \\frac{\\partial \\phi^2}{\\partial X} & \n                        \\frac{\\partial \\phi^2}{\\partial Y} &\n                        \\frac{\\partial \\phi^2}{\\partial Z} \\\\\n                        \\frac{\\partial \\phi^3}{\\partial X} & \n                        \\frac{\\partial \\phi^3}{\\partial Y} &\n                        \\frac{\\partial \\phi^3}{\\partial Z} \\\\\n                    \\end{bmatrix}\n                    $$"})]),(0,r._)("p",S,[(0,r.Uk)(" If we consider Finite Element method, we could express the mapping as: "),(0,r.Wm)(de,{latex:"     \n                    $$\n                    x= FX + c\n                    $$"})]),(0,r._)("p",C,[(0,r.Uk)(" The mapping "),(0,r.Wm)(de,{latex:"$$\\phi$$"}),(0,r.Uk)(" is a linear transform, which could be decomposed into volume change (the jacobian of the transform, "),(0,r.Wm)(de,{latex:"$$d\\phi=\\frac{\\partial x}{\\partial X}=F$$"}),(0,r.Uk)(") and translation c. ")]),(0,r._)("p",B,[(0,r.Uk)(" As "),(0,r.Wm)(de,{latex:"$$x_{10}=x_1-x_0=FX_1+c-FX_0-c=FX_{10}$$"}),(0,r.Uk)(" , where we eliminate the translation term c by subtraction. Therefore we could actually derive that "),(0,r.Wm)(de,{latex:"$$F = \\begin{bmatrix}\n    | & | & | & 0 \\\\ \n    x_{10} & x_{20} & x_{30} & 0 \\\\ \n    | & | & | & 0 \\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\\begin{bmatrix}\n    | & | & | & 0 \\\\ \n    X_{10} & X_{20} & X_{30} & 0 \\\\ \n    | & | & | & 0 \\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}^{-1}$$"})]),(0,r._)("p",O,[(0,r.Uk)(" Another different view is using homogeneous coordinates, which extend coordinates to an extra dimension to account for transformation. Then the transformation could be expressed as : "),(0,r.Wm)(de,{latex:"$$x=FX$$"}),(0,r.Uk)(": "),(0,r.Wm)(de,{latex:"\n$$\n\\begin{bmatrix}\n    |\\\\y\\\\|\\\\1\n\\end{bmatrix} = \\begin{bmatrix}\n    | & | & | & |\\\\\n    x_0 & x_1 & x_2 & x_3\\\\\n    | & | & | & |\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\\begin{bmatrix}\n    | & | & | & |\\\\\n    X_0 & X_1 & X_2 & X_3\\\\\n    | & | & | & |\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}^{-1}\n\\begin{bmatrix}\n    |\\\\Y\\\\|\\\\1\n\\end{bmatrix}\n$$"})]),(0,r._)("p",D,[(0,r.Uk)(" In this setting, translation is also introduce in F, but we want to represent deformation so translation is not welcomed. We may be able to eliminate the translation by removing the edge elements: "),(0,r.Wm)(de,{latex:"\n$$\n\\begin{bmatrix}\n     &  & & 0\\\\\n     & F & & 0\\\\\n     & & & 0\\\\\n     0 & 0& 0& 1\n\\end{bmatrix}\n\\leftarrow \\begin{bmatrix}\n    | & | & | & |\\\\\n    x_0 & x_1 & x_2 & x_3\\\\\n    | & | & | & |\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\\begin{bmatrix}\n    | & | & | & |\\\\\n    X_0 & X_1 & X_2 & X_3\\\\\n    | & | & | & |\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}^{-1}\n$$"}),(0,r.Uk)(": ")]),A])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[M])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",Y,[(0,r.Uk)(" In Green Strain "),(0,r.Wm)(de,{latex:"C=F^TF"}),(0,r.Uk)(", we eliminate the rotation term by multiplying the transpose with itself, it could be explained by SVD decomposition. "),(0,r.Wm)(de,{latex:"C"}),(0,r.Uk)(" will be close to identity matrix when no deformation happened. ")]),(0,r._)("p",Z,[(0,r.Uk)(" Therefore we could further subtract C by identity and get Green-st venant "),(0,r.Wm)(de,{latex:"E =\\frac{1}{2}(C-I)"}),(0,r.Uk)(", which is a representation for deformation. Where when no deformation happens it will be close to zero matrix. ")]),(0,r._)("p",G,[(0,r.Uk)(" We further use Saint Venant-Kirchhoff Model to mapping the strain to the energy density per reference area W. Then we could deriviate the energy density upon deformation and get"),(0,r.Wm)(de,{latex:"S=\\frac{\\partial W}{\\partial S}"}),(0,r.Uk)(" which is 2nd Piola-Kirchhoff stress tensor. "),(0,r.Wm)(de,{latex:"S = 2\\mu \\textbf{E} +\\lambda \\textbf{tr(E)I}"}),(0,r.Uk)(". ")]),(0,r._)("p",V,[(0,r.Uk)(" Have get the deformation gradient "),(0,r.Wm)(de,{latex:"\\mathbf{F}"}),(0,r.Uk)(", we could then do some more steps for each cell: ")]),(0,r._)("ol",null,[(0,r._)("li",L,[(0,r.Uk)(" Build right Cauchy-Green tensor: "),(0,r.Wm)(de,{latex:"\\mathbf{C} = \\mathbf{F}^T\\mathbf{F}"})]),(0,r._)("li",R,[(0,r.Uk)(" Build Green-st venant: "),(0,r.Wm)(de,{latex:"E = \\frac{1}{2}(\\textbf{C-I})"})]),(0,r._)("li",z,[(0,r.Uk)(" Build 2nd Piola-Kirchhoff: "),(0,r.Wm)(de,{latex:"S = 2\\mu \\textbf{E} +\\lambda \\textbf{tr(E)I}"})]),(0,r._)("li",K,[(0,r.Uk)(" Build 1st Piola-Kirchhoff: "),(0,r.Wm)(de,{latex:"\\mathbf{P=FS}"})])])])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[q])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",H,[(0,r.Uk)(" Energy density per reference area "),(0,r.Wm)(de,{latex:"$$W(G)$$"}),(0,r.Uk)(". ")]),(0,r._)("p",N,[(0,r.Uk)(" Then we could know the total energy: "),(0,r.Wm)(de,{latex:"$$E=\\int W(G)dA$$"}),(0,r.Uk)(". ")]),(0,r._)("p",Q,[(0,r.Uk)(" Given the energy we could compute the force by take derivative to the position: "),(0,r.Wm)(de,{latex:"$$\nf_i = -(\\frac{\\partial E}{\\partial x_i})^T = -\\frac{A}{n}Pn\n$$"}),(0,r.Uk)(". ")]),(0,r._)("p",J,[(0,r.Uk)(" The answer is related to area/volume as well as normal. Interestingly it is closely related to the matrix we choose previously for computation of F. The relation could be simply reveal by noticing the compound product of "),(0,r.Wm)(de,{latex:"$$X_{01}, X_{02}, X_{03}$$"}),(0,r.Uk)(" and their permutations should always be the volume. ")])])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[ee])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",te,[(0,r.Uk)(" In this way we could compute the force each cell gives to each vertex. By iterating through all the cells, we could accumulate all the traction force given to a vertex by different cells. "),(0,r.Wm)(de,{latex:"$$\nf_v=\\frac{1}{n}\\sum_{c\\succ v}{\\rm P}_c{\\rm n}_{c,v}A_{c,v}\n$$"})]),(0,r._)("p",ae,[(0,r.Uk)(" (Adjoint) All the vertices in the cell gives their force to the cell. "),(0,r.Wm)(de,{latex:"$$\n                  \\sum_c \\textbf{tr}P_c(\\mathring{F}_c^T)V_c = \\sum_V-f_V^T\\mathring{x}_V\n$$"})])])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[ne])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[ie])),_:1}),(0,r.Wm)(de,{latex:"$$\n                \\mathrm{m_v\\ddot{x}_v=f_v}\n                $$"}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",le,[(0,r.Uk)(" The implementation is based on "),(0,r.Wm)(fe,{href:"https://github.com/SuikaSibyl/SIByLEngine2023/",target:"_blank",type:"primary"},{default:(0,r.w5)((()=>[(0,r.Uk)("my own Engine")])),_:1}),(0,r.Uk)(", the simulation code is on CPP and the visualization is on Vulkan: ")])])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(ue,{span:17},{default:(0,r.w5)((()=>[re])),_:1})])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[oe])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"left"},{default:(0,r.w5)((()=>[(0,r._)("p",se,[(0,r.Uk)(" The implementation is based on "),(0,r.Wm)(fe,{href:"https://github.com/SuikaSibyl/SIByLEngine2023/",target:"_blank",type:"primary"},{default:(0,r.w5)((()=>[(0,r.Uk)("my own Engine")])),_:1}),(0,r.Uk)(", the simulation code is on CPP and the visualization is on Vulkan: ")])])),_:1}),(0,r.Wm)(s,{class:"row-bg",justify:"center"},{default:(0,r.w5)((()=>[(0,r.Wm)(ue,{span:17},{default:(0,r.w5)((()=>[ce])),_:1})])),_:1})])),_:1}),(0,r.Wm)(he),(0,r.Wm)(pe,null,{default:(0,r.w5)((()=>[(0,r.Wm)(fe,{href:"https://suikasibyl.github.io/",target:"_blank",type:"primary"},{default:(0,r.w5)((()=>[(0,r.Uk)("My Homepage")])),_:1})])),_:1})])),_:1})])),_:1})])),_:1})])),_:1})])])}var ue={name:"ReportPage",mounted(){},props:{},data(){return{formula:"$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$"}}},de=a(89);const me=(0,de.Z)(ue,[["render",fe],["__scopeId","data-v-3dbb9389"]]);var he=me,pe={name:"App",components:{ReportPage:he}};const be=(0,de.Z)(pe,[["render",o]]);var ge=be;function we(){const e=document.getElementById("elementId");(0,l.kr)(e)}(0,l.c1)({},we);const ye=(0,n.ri)(ge);ye.use(i.Z),ye.use(l.ZP),ye.mount("#app")}},t={};function a(n){var i=t[n];if(void 0!==i)return i.exports;var l=t[n]={exports:{}};return e[n].call(l.exports,l,l.exports,a),l.exports}a.m=e,function(){var e=[];a.O=function(t,n,i,l){if(!n){var r=1/0;for(f=0;f<e.length;f++){n=e[f][0],i=e[f][1],l=e[f][2];for(var o=!0,s=0;s<n.length;s++)(!1&l||r>=l)&&Object.keys(a.O).every((function(e){return a.O[e](n[s])}))?n.splice(s--,1):(o=!1,l<r&&(r=l));if(o){e.splice(f--,1);var c=i();void 0!==c&&(t=c)}}return t}l=l||0;for(var f=e.length;f>0&&e[f-1][2]>l;f--)e[f]=e[f-1];e[f]=[n,i,l]}}(),function(){a.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return a.d(t,{a:t}),t}}(),function(){a.d=function(e,t){for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})}}(),function(){a.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){a.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)}}(),function(){var e={143:0};a.O.j=function(t){return 0===e[t]};var t=function(t,n){var i,l,r=n[0],o=n[1],s=n[2],c=0;if(r.some((function(t){return 0!==e[t]}))){for(i in o)a.o(o,i)&&(a.m[i]=o[i]);if(s)var f=s(a)}for(t&&t(n);c<r.length;c++)l=r[c],a.o(e,l)&&e[l]&&e[l][0](),e[l]=0;return a.O(f)},n=self["webpackChunkmiscsim23"]=self["webpackChunkmiscsim23"]||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))}();var n=a.O(void 0,[998],(function(){return a(7338)}));n=a.O(n)})();
//# sourceMappingURL=app.c8cc5c1e.js.map